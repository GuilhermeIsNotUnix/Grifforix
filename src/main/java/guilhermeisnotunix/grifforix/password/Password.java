package guilhermeisnotunix.grifforix.password;

import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.MessageDigest;

/** Represents a password
 * @author Guilherme Faura
 * @author <a href="https://guilhermeisnotunix.github.io">guilhermeisnotunix</a>
 * @author <a href="https://github.com/guilhermeisnotunix">GitHub</a>
 * @version 0.8.2-alpha
 */

public class Password {
    static final String Lowercase = "abcdefghijklmnopqrstuvwxyz"; //length() == 26
    static final String Uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; //length() == 26
    static final String Symbols = "\"'!@#$%&*()_-+={}[]~^`<>,.:;?/"; //length() == 30
    static final String Numbers = "0123456789"; //length() == 10
    static final String AllCharacters = Lowercase + Uppercase + Symbols + Numbers; //length() == 92

    static final int MinimumLength = 10;
    static final int MaximumLength = 256;
    static final String GrifforixVersion = "v.0.8.2-alpha";

    /** Gets the version of the Grifforix software.
     * @return a String representing the version of the software.
     */
    public static String getGrifforixVersion() {
        return GrifforixVersion;
    }

    /** Generates a secure random number BigInteger for later use in the algorithm.
     * @param max The maximum value that the generated random number can reach.
     * @return a BigInteger object representing a non-negative random number, generated by the SecureRandom class, that is less than the specified maximum value.
     * @throws RuntimeException If an error occurs when trying to obtain the secure algorithm.
     */
    public static BigInteger generateRandomNumber(BigInteger max) {
        SecureRandom secureRandom;
        try {
            secureRandom = SecureRandom.getInstanceStrong();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("An error occurred while trying to obtain secure algorithm.", e);
        }

        BigInteger randomNumber;
        do {
            byte[] randomBytes = new byte[max.bitLength() / 8 + 1]; //Creates bytes of the size needed to store "max", also performing byte arithmetic, hence the division by 8, and adds it to 1 as a precaution to ensure there is enough space to store the random number
            secureRandom.nextBytes(randomBytes);
            randomNumber = new BigInteger(1, randomBytes);
        } while(randomNumber.compareTo(max) >= 0);

        return randomNumber;
    }

    /** Generates a random character based on the character sets defined at the top of the class.
     * The method uses the other previous method generateRandomNumber() using the "max" parameter as the size of the AllCharacters String and returning which character is equivalent to the index in the String.
     * @return a character representing the generated random character based on the character sets.
     */
    public static char generateRandomCharacter() {
        int randomIndex = generateRandomNumber(BigInteger.valueOf(AllCharacters.length())).intValue();
        return AllCharacters.charAt(randomIndex);
    }

    public static char[] generateNewPassword(int len) {
        if (len < MinimumLength || len > MaximumLength) {
            throw new IllegalArgumentException("Error: Password must have minimum " + MinimumLength +
                    " characters and max " + MaximumLength + " characters.");
        }

        char[] password = new char[len];

        for (int i = 0; i < len; i++) {
            password[i] = generateRandomCharacter();
        }

        return password;
    }

    public static String hashPassword(String password) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hashedBytes = md.digest(password.getBytes());

            StringBuilder hexString = new StringBuilder();
            for(byte hashedByte : hashedBytes) {
                hexString.append(String.format("%02x", hashedByte));
            }

            return hexString.toString();
        } catch(NoSuchAlgorithmException e) {
            throw new RuntimeException("Error while trying to obtain hash algorithm.", e);
        }
    }

    public static boolean checkPasswordHash(String password, String hashedPassword) {
        String newHashedPassword = hashPassword(password);
        return newHashedPassword.equals(hashedPassword);
    }
}
