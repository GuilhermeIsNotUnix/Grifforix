package guilhermeisnotunix.grifforix.password;

import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.MessageDigest;

/** <p>This class represents a password, from its definition, that is, with the character sets to be considered in the processes, the size security limits for a password, to the methods for generating a random password itself.</p>
 *
 * <p>Basically, there is a method for the secure and random generation of a number called generateRandomNumber(BigInteger max) that uses cryptographically secure methods from the Java's SecureRandom class. We use this previous method within another method called generateRandomCharacter() taking into account our character sets defined at the top of the class, so with the randomly generated number we apply it to the alphabets and extract a character equivalent to the generated number. So we have a way to generate random characters.</p>
 *
 * <p>Next, we move on to creating an actual password, with the generateNewPassword(int len) method, which first checks whether the passed length is within the security size limits defined in the top of the Password class (MinimumLength and MaximumLength), which in principle uses the technique previously mentioned of generating random characters within a loop, generating character by character until the desired size of the password.</p>
 *
 * <p>For a more detailed and less general explanation, see the methods documentation</p>
 *
 * @author Guilherme Faura
 * @author <a href="https://guilhermeisnotunix.github.io">guilhermeisnotunix</a>
 * @author <a href="https://github.com/guilhermeisnotunix">GitHub</a>
 * @version 0.9.2-alpha
 */

public class Password {
    static final String Lowercase = "abcdefghijklmnopqrstuvwxyz"; //length() == 26
    static final String Uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; //length() == 26
    static final String Symbols = "\"'!@#$%&*()_-+={}[]~^`<>,.:;?/"; //length() == 30
    static final String Numbers = "0123456789"; //length() == 10
    static final String AllCharacters = Lowercase + Uppercase + Symbols + Numbers; //length() == 92

    static final int MinimumLength = 10;
    static final int MaximumLength = 256;
    static final String GrifforixVersion = "v.0.9.2-alpha";

    /** Gets the version of the Grifforix software.
     * @return a String representing the version of the software.
     */
    public static String getGrifforixVersion() {
        return GrifforixVersion;
    }

    /** Generates a secure random number BigInteger for later use in the algorithm.
     * @param max The maximum value that the generated random number can reach.
     * @return a BigInteger object representing a non-negative random number, generated by the SecureRandom class, that is less than the specified maximum value.
     * @throws RuntimeException If an error occurs when trying to obtain the secure algorithm.
     */
    public static BigInteger generateRandomNumber(BigInteger max) {
        SecureRandom secureRandom;
        try {
            secureRandom = SecureRandom.getInstanceStrong();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("An error occurred while trying to obtain secure algorithm.", e);
        }

        BigInteger randomNumber;
        do {
            byte[] randomBytes = new byte[max.bitLength() / 8 + 1]; //Creates bytes of the size needed to store "max", also performing byte arithmetic, hence the division by 8, and adds it to 1 as a precaution to ensure there is enough space to store the random number
            secureRandom.nextBytes(randomBytes);
            randomNumber = new BigInteger(1, randomBytes);
        } while(randomNumber.compareTo(max) >= 0);

        return randomNumber;
    }

    /** <p>Generates a random character based on the character sets defined at the top of the class.</p>
     * <p>The method uses the other previous method generateRandomNumber() using the "max" parameter as the size of the AllCharacters String and returning which character is equivalent to the index in the String.</p>
     * @return a character representing the generated random character based on the character sets.
     */
    public static char generateRandomCharacter() {
        int randomIndex = generateRandomNumber(BigInteger.valueOf(AllCharacters.length())).intValue();
        return AllCharacters.charAt(randomIndex);
    }

    /** <p>Generates a random password given a desired length that is within password length security limits.</p>
     * <p>First, the method checks whether the len size is respecting the password length security limits defined at the top of the class (MinimumLength and MaximumLength). Then, a for loop is created to fill in the password char[] using the previous random character method (generateRandomCharacter()). In other words, filling each index of the password character by character with random characters up to the desired password length that was given.</p>
     * @param len The desired length of the random password to be generated.
     * @return a char[] representing the actually randomly generated password. <p>Why char[] instead of String? Because Strings in Java are immutable by default and managed by the garbage collector, which means a possible security vulnerability, since if a String were used for the password there would not be much control over when the password is actually erased from memory or if it is still exposed in memory and with char[] I can manipulate it manually if I want in a later process to, for example, overwrite it with noise to avoid reverse engineering attacks that would exploit exposed Strings in memory.</p>
     */
    public static char[] generateNewPassword(int len) {
        if (len < MinimumLength || len > MaximumLength) {
            throw new IllegalArgumentException("Error: Password must have minimum " + MinimumLength +
                    " characters and max " + MaximumLength + " characters.");
        }

        char[] password = new char[len];

        for (int i = 0; i < len; i++) {
            password[i] = generateRandomCharacter();
        }

        return password;
    }

    public static String hashPassword(String password) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hashedBytes = md.digest(password.getBytes());

            StringBuilder hexString = new StringBuilder();
            for(byte hashedByte : hashedBytes) {
                hexString.append(String.format("%02x", hashedByte));
            }

            return hexString.toString();
        } catch(NoSuchAlgorithmException e) {
            throw new RuntimeException("Error while trying to obtain hash algorithm.", e);
        }
    }

    public static boolean checkPasswordHash(String password, String hashedPassword) {
        String newHashedPassword = hashPassword(password);
        return newHashedPassword.equals(hashedPassword);
    }
}
